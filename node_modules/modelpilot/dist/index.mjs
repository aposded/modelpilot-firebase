import require$$0 from 'axios';

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var src = {exports: {}};

/**
 * ModelPilot Error Classes
 * OpenAI-compatible error handling
 */

/**
 * Base ModelPilot error class
 */
let ModelPilotError$1 = class ModelPilotError extends Error {
  constructor(message, options = {}) {
    super(message);
    this.name = 'ModelPilotError';
    this.type = options.type || 'modelpilot_error';
    this.code = options.code;
    this.param = options.param;
  }
};

/**
 * API error - for HTTP errors from the ModelPilot API
 */
let APIError$1 = class APIError extends ModelPilotError$1 {
  constructor(message, status, response = null) {
    super(message, { type: 'api_error' });
    this.name = 'APIError';
    this.status = status;
    this.response = response;
    this.code = response?.error?.code;
    this.param = response?.error?.param;
  }
};

/**
 * Authentication error - for invalid API keys
 */
let AuthenticationError$1 = class AuthenticationError extends APIError$1 {
  constructor(message) {
    super(message, 401);
    this.name = 'AuthenticationError';
    this.type = 'authentication_error';
  }
};

/**
 * Rate limit error - for rate limiting
 */
let RateLimitError$1 = class RateLimitError extends APIError$1 {
  constructor(message) {
    super(message, 429);
    this.name = 'RateLimitError';
    this.type = 'rate_limit_exceeded';
  }
};

/**
 * Invalid request error - for malformed requests
 */
let InvalidRequestError$2 = class InvalidRequestError extends APIError$1 {
  constructor(message, param = null) {
    super(message, 400);
    this.name = 'InvalidRequestError';
    this.type = 'invalid_request_error';
    this.param = param;
  }
};

var errors = {
  ModelPilotError: ModelPilotError$1,
  APIError: APIError$1,
  AuthenticationError: AuthenticationError$1,
  RateLimitError: RateLimitError$1,
  InvalidRequestError: InvalidRequestError$2};

/**
 * ModelPilot Utility Functions
 * Helper functions for the ModelPilot client
 */

const { InvalidRequestError: InvalidRequestError$1 } = errors;

/**
 * Validate client configuration
 * @param {Object} config - Configuration object
 * @returns {Object} Validated configuration
 */
function validateConfig$1(config) {
  if(!config.apiKey) {
    throw new Error('ModelPilot API key is required. Get one at https://modelpilot.co');
  }

  if(typeof config.apiKey!=='string') {
    throw new Error('API key must be a string');
  }

  if(config.baseURL&&typeof config.baseURL!=='string') {
    throw new Error('baseURL must be a string');
  }

  if(config.timeout&&(typeof config.timeout!=='number'||config.timeout<=0)) {
    throw new Error('timeout must be a positive number');
  }

  if(config.maxRetries&&(typeof config.maxRetries!=='number'||config.maxRetries<0)) {
    throw new Error('maxRetries must be a non-negative number');
  }

  return config;
}

/**
 * Build headers for API requests
 * @param {string} apiKey - API key (should start with 'mp_')
 * @param {Object} additionalHeaders - Additional headers
 * @returns {Object} Headers object
 */
function buildHeaders$1(apiKey,additionalHeaders={}) {
  // Ensure API key has proper format for ModelPilot
  if(!apiKey.startsWith('mp_')) {
    throw new Error('Invalid ModelPilot API key format. API key must start with "mp_"');
  }

  return {
    'Authorization': `Bearer ${apiKey}`,
    'User-Agent': 'modelpilot-js/1.0.0',
    'X-Client-Library': 'modelpilot-js',
    'Content-Type': 'application/json',
    ...additionalHeaders
  };
}

/**
 * Handle API response
 * @param {Object} response - Axios response object
 * @returns {Object} Response object
 */
function handleResponse$1(response) {
  // Return the response as-is for successful requests
  return response;
}

/**
 * Validate messages array for chat completions
 * @param {Array} messages - Messages array
 */
function validateMessages$1(messages) {
  if(!Array.isArray(messages)) {
    throw new Error('messages must be an array');
  }

  if(messages.length===0) {
    throw new InvalidRequestError$1('messages array cannot be empty','messages');
  }

  for(const [index,message] of messages.entries()) {
    if(!message||typeof message!=='object') {
      throw new Error(`messages[${index}] must be an object`);
    }

    if(!message.role) {
      throw new Error(`messages[${index}].role is required`);
    }

    if(!['system','user','assistant','function','tool'].includes(message.role)) {
      throw new Error(`messages[${index}].role must be one of: system, user, assistant, function, tool`);
    }

    if(!message.content&&!message.function_call&&!message.tool_calls) {
      throw new Error(`messages[${index}].content is required when role is not function or tool`);
    }
  }
}

/**
 * Validate function definitions
 * @param {Array} functions - Functions array
 */
function validateFunctions$1(functions) {
  if(!Array.isArray(functions)) {
    throw new Error('functions must be an array');
  }

  for(const [index,func] of functions.entries()) {
    if(!func||typeof func!=='object') {
      throw new Error(`functions[${index}] must be an object`);
    }

    if(!func.name||typeof func.name!=='string') {
      throw new Error(`functions[${index}].name is required and must be a string`);
    }

    if(func.description&&typeof func.description!=='string') {
      throw new Error(`functions[${index}].description must be a string`);
    }

    if(func.parameters&&typeof func.parameters!=='object') {
      throw new Error(`functions[${index}].parameters must be an object`);
    }
  }
}

/**
 * Validate tools array
 * @param {Array} tools - Tools array
 */
function validateTools$1(tools) {
  if(!Array.isArray(tools)) {
    throw new Error('tools must be an array');
  }

  for(const [index,tool] of tools.entries()) {
    if(!tool||typeof tool!=='object') {
      throw new Error(`tools[${index}] must be an object`);
    }

    if(!tool.type) {
      throw new Error(`tools[${index}].type is required`);
    }

    if(tool.type==='function') {
      if(!tool.function) {
        throw new Error(`tools[${index}].function is required when type is 'function'`);
      }

      validateFunctions$1([tool.function]);
    }
  }
}

/**
 * Convert streaming data to text
 * @param {string} chunk - Raw chunk data
 * @returns {string|null} Extracted text or null
 */
function extractStreamingText$1(chunk) {
  try {
    // Remove 'data: ' prefix if present
    const cleanChunk=chunk.replace(/^data: /,'');

    // Skip empty lines and [DONE] marker
    if(!cleanChunk.trim()||cleanChunk.trim()==='[DONE]') {
      return null;
    }

    const parsed=JSON.parse(cleanChunk);

    // Extract content from different possible structures
    if(parsed.choices&&parsed.choices[0]) {
      const choice=parsed.choices[0];

      // Handle delta format (streaming)
      if(choice.delta&&choice.delta.content) {
        return choice.delta.content;
      }

      // Handle message format (non-streaming)
      if(choice.message&&choice.message.content) {
        return choice.message.content;
      }
    }

    return null;
  } catch(error) {
    // Ignore parsing errors for malformed chunks
    return null;
  }
}

var utils={
  validateConfig: validateConfig$1,
  buildHeaders: buildHeaders$1,
  handleResponse: handleResponse$1,
  validateMessages: validateMessages$1,
  validateFunctions: validateFunctions$1,
  validateTools: validateTools$1,
  extractStreamingText: extractStreamingText$1};

/**
 * ModelPilot Chat Completions API
 * OpenAI-compatible chat completions with intelligent model routing
 */

const {validateMessages,validateFunctions,validateTools,extractStreamingText}=utils;
const {InvalidRequestError}=errors;

/**
 * Chat Completions API class
 */
let ChatCompletions$1 = class ChatCompletions {
  constructor(client) {
    this.client=client;
  }

  /**
   * Create a chat completion
   * @param {Object} params - Chat completion parameters
   * @param {Array} params.messages - Array of message objects
   * @param {string} [params.model] - Model to use (optional with ModelPilot routing)
   * @param {number} [params.max_tokens] - Maximum tokens to generate
   * @param {number} [params.temperature] - Sampling temperature
   * @param {number} [params.top_p] - Nucleus sampling parameter
   * @param {number} [params.frequency_penalty] - Frequency penalty
   * @param {number} [params.presence_penalty] - Presence penalty
   * @param {Array} [params.stop] - Stop sequences
   * @param {boolean} [params.stream] - Enable streaming
   * @param {Array} [params.functions] - Function definitions (deprecated, use tools)
   * @param {string} [params.function_call] - Function call behavior
   * @param {Array} [params.tools] - Tool definitions
   * @param {Object} [params.tool_choice] - Tool choice behavior
   * @param {Object} [params.response_format] - Response format specification
   * @param {string} [params.user] - User identifier
   * @returns {Promise<Object>} Chat completion response
   */
  async create(params) {
    // Validate required parameters
    if(!params.messages) {
      throw new InvalidRequestError('messages is required','messages');
    }

    validateMessages(params.messages);

    // Validate optional parameters
    if(params.functions) {
      validateFunctions(params.functions);
    }

    if(params.tools) {
      validateTools(params.tools);
    }

    if(params.max_tokens&&(typeof params.max_tokens!=='number'||params.max_tokens<=0)) {
      throw new InvalidRequestError('max_tokens must be a positive number','max_tokens');
    }

    if(params.temperature&&(typeof params.temperature!=='number'||params.temperature<0||params.temperature>2)) {
      throw new InvalidRequestError('temperature must be between 0 and 2','temperature');
    }

    if(params.top_p&&(typeof params.top_p!=='number'||params.top_p<=0||params.top_p>1)) {
      throw new InvalidRequestError('top_p must be between 0 and 1','top_p');
    }

    // Build request payload
    const requestPayload={
      messages: params.messages,
      routerId: this.client.routerId,
      ...this._buildOptionalParams(params)
    };

    // Handle streaming vs non-streaming
    if(params.stream) {
      return this._createStreamingCompletion(requestPayload);
    } else {
      return this._createCompletion(requestPayload);
    }
  }

  /**
   * Build optional parameters for the request
   * @private
   */
  _buildOptionalParams(params) {
    const optional={};

    // Model selection (optional with ModelPilot)
    if(params.model) {
      optional.model=params.model;
    }

    // Sampling parameters
    if(params.max_tokens!==undefined) optional.max_tokens=params.max_tokens;
    if(params.temperature!==undefined) optional.temperature=params.temperature;
    if(params.top_p!==undefined) optional.top_p=params.top_p;
    if(params.frequency_penalty!==undefined) optional.frequency_penalty=params.frequency_penalty;
    if(params.presence_penalty!==undefined) optional.presence_penalty=params.presence_penalty;
    if(params.stop!==undefined) optional.stop=params.stop;

    // Function calling (legacy)
    if(params.functions!==undefined) optional.functions=params.functions;
    if(params.function_call!==undefined) optional.function_call=params.function_call;

    // Tool calling (modern)
    if(params.tools!==undefined) optional.tools=params.tools;
    if(params.tool_choice!==undefined) optional.tool_choice=params.tool_choice;

    // Response format
    if(params.response_format!==undefined) optional.response_format=params.response_format;

    // User identifier
    if(params.user!==undefined) optional.user=params.user;

    // Streaming
    if(params.stream!==undefined) optional.stream=params.stream;

    return optional;
  }

  /**
   * Create a standard (non-streaming) completion
   * @private
   */
  async _createCompletion(payload) {
    // ModelPilot router expects routerId in the URL path
    const endpoint=`/router/${this.client.routerId}`;

    const response=await this.client.request(endpoint,{
      method: 'POST',
      data: payload
    });

    return response;
  }

  /**
   * Create a streaming completion
   * @private
   */
  async _createStreamingCompletion(payload) {
    // ModelPilot router expects routerId in the URL path
    const endpoint=`/router/${this.client.routerId}`;

    const response=await this.client.httpClient({
      url: endpoint,
      method: 'POST',
      data: payload,
      responseType: 'stream',
      headers: {
        'Accept': 'text/event-stream',
        'Cache-Control': 'no-cache'
      }
    });

    return new ChatCompletionStream(response.data);
  }
};

/**
 * Chat Completion Stream class for handling streaming responses
 */
class ChatCompletionStream {
  constructor(stream) {
    this.stream=stream;
    this._buffer='';
  }

  /**
   * Async iterator for streaming chunks
   */
  async *[Symbol.asyncIterator]() {
    for await(const chunk of this.stream) {
      this._buffer+=chunk.toString();

      // Process complete lines
      const lines=this._buffer.split('\n');
      this._buffer=lines.pop()||''; // Keep incomplete line in buffer

      for(const line of lines) {
        if(line.trim()) {
          const text=extractStreamingText(line);
          if(text!==null) {
            yield {
              choices: [{
                delta: {content: text},
                index: 0,
                finish_reason: null
              }],
              created: Math.floor(Date.now()/1000),
              model: 'modelpilot-routed',
              object: 'chat.completion.chunk'
            };
          }
        }
      }
    }

    // Process any remaining buffer content
    if(this._buffer.trim()) {
      const text=extractStreamingText(this._buffer);
      if(text!==null) {
        yield {
          choices: [{
            delta: {content: text},
            index: 0,
            finish_reason: null
          }],
          created: Math.floor(Date.now()/1000),
          model: 'modelpilot-routed',
          object: 'chat.completion.chunk'
        };
      }
    }

    // Send final chunk with finish_reason
    yield {
      choices: [{
        delta: {},
        index: 0,
        finish_reason: 'stop'
      }],
      created: Math.floor(Date.now()/1000),
      model: 'modelpilot-routed',
      object: 'chat.completion.chunk'
    };
  }

  /**
   * Convert stream to array of chunks
   */
  async toArray() {
    const chunks=[];
    for await(const chunk of this) {
      chunks.push(chunk);
    }
    return chunks;
  }

  /**
   * Get the final completion text
   */
  async getText() {
    let text='';
    for await(const chunk of this) {
      if(chunk.choices[0].delta.content) {
        text+=chunk.choices[0].delta.content;
      }
    }
    return text;
  }
}

var chat={
  ChatCompletions: ChatCompletions$1};

/**
 * ModelPilot JavaScript/TypeScript Client Library
 * OpenAI-compatible interface for intelligent model routing
 */

const axios=require$$0;
const {ChatCompletions}=chat;
const {ModelPilotError,APIError,AuthenticationError,RateLimitError}=errors;
const {validateConfig,buildHeaders,handleResponse}=utils;

/**
 * Main ModelPilot client class
 * Provides OpenAI-compatible API for intelligent model routing
 */
class ModelPilot {
  /**
   * Initialize ModelPilot client
   * @param {Object} config - Configuration options
   * @param {string} config.apiKey - ModelPilot API key (required)
   * @param {string} [config.baseURL] - Base URL for ModelPilot API
   * @param {string} [config.routerId] - Router ID to use for requests
   * @param {number} [config.timeout] - Request timeout in milliseconds
   * @param {Object} [config.defaultHeaders] - Default headers to include
   * @param {number} [config.maxRetries] - Maximum number of retries
   */
  constructor(config={}) {
    // Validate configuration
    const validatedConfig=validateConfig(config);

    this.apiKey=validatedConfig.apiKey;
    this.baseURL=validatedConfig.baseURL||'https://modelpilot.co/api';
    this.routerId=validatedConfig.routerId;
    this.timeout=validatedConfig.timeout||30000;
    this.defaultHeaders=validatedConfig.defaultHeaders||{};
    this.maxRetries=validatedConfig.maxRetries||3;

    // Validate API key format
    if(!this.apiKey.startsWith('mp_')) {
      throw new Error('Invalid ModelPilot API key format. API key must start with "mp_". Get your API key from https://modelpilot.co');
    }

    // Validate Router ID
    if(!this.routerId) {
      throw new Error('Router ID is required. Get your Router ID from https://modelpilot.co');
    }

    // Initialize API sections
    this.chat=new ChatCompletions(this);

    // Create axios instance with default configuration
    this.httpClient=axios.create({
      baseURL: this.baseURL,
      timeout: this.timeout,
      headers: {
        'Content-Type': 'application/json',
        ...this.defaultHeaders
      }
    });

    // Add request interceptor for authentication
    this.httpClient.interceptors.request.use((config) => {
      config.headers=buildHeaders(this.apiKey,config.headers);
      return config;
    });

    // Add response interceptor for error handling
    this.httpClient.interceptors.response.use(
      (response) => handleResponse(response),
      (error) => this._handleError(error)
    );
  }

  /**
   * Handle HTTP errors and convert to ModelPilot errors
   * @private
   */
  // 
  _handleError(error) {
    if(error.response) {
      const {status,data}=error.response;

      switch(status) {
        case 401:
          throw new AuthenticationError(data.message||'Invalid API key');
        case 429:
          throw new RateLimitError(data.message||'Rate limit exceeded');
        case 400:
          throw new APIError(data.message||'Bad request',status,data);
        case 422:
          throw new APIError(data.message||'Bad request',status,data);
        default:
          throw new APIError(data.message||'API error',status,data);
      }
    } else if(error.request) {
      throw new ModelPilotError('Network error: No response received');
    } else {
      throw new ModelPilotError(`Request error: ${error.message}`);
    }
  }

  /**
   * Make authenticated request to ModelPilot API
   * @param {string} endpoint - API endpoint
   * @param {Object} options - Request options
   * @returns {Promise<Object>} Response data
   */
  async request(endpoint,options={}) {
    const config={
      url: endpoint,
      method: options.method||'POST',
      data: options.data,
      params: options.params,
      headers: options.headers,
      ...options
    };

    let lastError;

    // Retry logic
    for(let attempt=0;attempt<=this.maxRetries;attempt++) {
      try {
        const response=await this.httpClient(config);
        return response.data;
      } catch(error) {
        lastError=error;

        // Don't retry on authentication or client errors
        if(error instanceof AuthenticationError||
          (error instanceof APIError&&error.status<500)) {
          throw error;
        }

        // Don't retry on last attempt
        if(attempt===this.maxRetries) {
          break;
        }

        // Exponential backoff
        const delay=Math.min(1000*Math.pow(2,attempt),10000);
        await new Promise(resolve => setTimeout(resolve,delay));
      }
    }

    throw lastError;
  }

  /**
   * Get router configuration
   * @returns {Promise<Object>} Router configuration
   */
  async getRouterConfig() {
    const endpoint=`/getRouterConfig/${this.routerId}`;
    return this.request(endpoint,{
      method: 'GET'
    });
  }

  /**
   * Get available models
   * @returns {Promise<Array>} Available models
   */
  async getModels() {
    const endpoint='/getModels';
    return this.request(endpoint,{
      method: 'GET'
    });
  }
}

src.exports=ModelPilot;
var ModelPilot_1 = src.exports.ModelPilot=ModelPilot;
var ModelPilotError_1 = src.exports.ModelPilotError=ModelPilotError;
var APIError_1 = src.exports.APIError=APIError;
var AuthenticationError_1 = src.exports.AuthenticationError=AuthenticationError;
var RateLimitError_1 = src.exports.RateLimitError=RateLimitError;

var srcExports = src.exports;
var index = /*@__PURE__*/getDefaultExportFromCjs(srcExports);

export { APIError_1 as APIError, AuthenticationError_1 as AuthenticationError, ModelPilot_1 as ModelPilot, ModelPilotError_1 as ModelPilotError, RateLimitError_1 as RateLimitError, index as default };
